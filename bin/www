#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('cryptid:server');
var http = require('http');

const mongoose = require("mongoose");

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */
const io = require('socket.io')(server);
const dbpass = "Qwertyui1";
const dbuser = "neyon71133";
mongoose.connect(`mongodb+srv://${dbuser}:${dbpass}@cluster0.zbdv8in.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0`)
  .then(() => {
    console.log("db connected");
    server.listen(port);
    server.on('error', onError);
    server.on('listening', onListening);
  })
  .catch((err) => {
    console.error("Error connecting to the database:", err);
  });


/**
 * Normalize a port into a number, string, or false.
 */

const custom_lobbies = [];
const lobbies = [];
const curr_ind=0;

let next_custom=0;
function lobby(){
  this.players=[];
  this.player_sockets=[];
  this.lobby_id=-1;
  this.mode ="temp";
  this.started=false;
}

io.on('connection', (socket) => {
  console.log('User connected');
  //socket.emit("new_player");
  //socket.emit("identity",{found:"found"});
  io.to(socket.id).emit("identity",{found:"found"});
  //check if it's a return
  
  socket.on("create",(what)=>{
      let some = new lobby();
      some.players.push(what.username);
      some.player_sockets.push(socket.id);
      some.lobby_id=next_custom;
      some.mode=what.mode;
      next_custom++;
      custom_lobbies.push(some);
      io.to(socket.id).emit("create-res",{id:some.lobby_id});
  });

  socket.on("join",(data)=>{
      const index = custom_lobbies.findIndex(car => car.lobby_id == data.code);
      if (index==-1){
          io.to(socket.id).emit("not-found");
      }
      else{
          custom_lobbies[index].player_sockets.push(socket.id);
          custom_lobbies[index].players.push(data.username);
          for (let i=0;i<custom_lobbies[index].player_sockets.length;i++){
              io.to(custom_lobbies[index].player_sockets[i]).emit("new_player",{name:data.username});
          }
          io.to(socket.id).emit("others",{others:custom_lobbies[index].players});
      }
  });

  socket.on("play",(data)=>{
      const index = lobbies.findIndex(car => car.mode==data.mode&&car.started == false);
      if (index==-1){
          let temp = new lobby();
          temp.lobby_id=curr_ind;
          temp.player_sockets.push(socket.id);
          temp.players.push(data.username);
          temp.mode=data.mode;
          lobbies.push(temp);
          io.to(socket.id).emit("found",{data:"uhmm what"});
          console.log("well what");
          //console.log(lobbies);
      }
      else{
          lobbies[index].player_sockets.push(socket.id);
          lobbies[index].players.push(data.username);
          console.log("I am the one");
          //console.log(lobbies);
          for (let i=0;i<lobbies[index].player_sockets.length;i++){
              console.log(`sending to ${lobbies[index].player_sockets[i]}`);
              io.to(lobbies[index].player_sockets[i]).emit("newplayer",{name:data.username});
          }
          io.to(socket.id).emit("others",{others:lobbies[index].players});
          if (lobbies[index].players.length == 5){
              //full, so start
              for (let i=0;i<lobbies[index].player_sockets.length;i++){
                  io.to(lobbies[index].player_sockets[i]).emit("start-game");
              }
              lobbies[index].started=true;
          }
      }

  });

  socket.on('disconnect', () => {
      console.log(`user disconnected:${socket.id}`);
      for (let i=0;i<lobbies.length;i++){
        for (let j=0;j<lobbies[i].player_sockets.length;j++){
          if (lobbies[i].player_sockets[j]==socket.id){
            let temp_name=lobbies[i].players[j];
            lobbies[i].player_sockets.splice(j,1);
            lobbies[i].players.splice(j,1);
            for (let z=0;z<lobbies[i].player_sockets.length;z++){
              io.to(lobbies[i].player_sockets[z]).emit("player_lost",{username:temp_name});
            }
          }

        }
      }
      for (let i=0;i<custom_lobbies.length;i++){
        for (let j=0;j<custom_lobbies[i].player_sockets.length;j++){
          if (custom_lobbies[i].player_sockets[j]==socket.id){
            let temp_name=custom_lobbies[i].players[j];
            custom_lobbies[i].player_sockets.splice(j,1);
            custom_lobbies[i].players.splice(j,1);
            for (let z=0;z<custom_lobbies[i].player_sockets.length;z++){
              io.to(custom_lobbies[i].player_sockets[z]).emit("player_lost",{username:temp_name});
            }
          }

        }
      }
  });
});

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
